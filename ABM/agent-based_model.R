set.seed(7) # for reproducibility

source('~/ABM/mosquito_model.R')

#could use any real first date and it should run
time_zero_date<-as.Date("2025-01-01")

#this just saves the times
num_years<-1
curr_year<-as.numeric(format(time_zero_date, format="%Y"))
curr_month<-as.numeric(format(time_zero_date, format="%m"))
the_season<-curr_month
the_year<-curr_year

mydates<-data.frame(matrix(NA,nrow=(num_years*12),ncol=2))
names(mydates)<-c("days_until_rate_change","month")
month_formating<-c("-01","-02","-03","-04","-05","-06","-07","-08","-09","-10","-11","-12")
for(ii in 0:(num_years-1)){
  for(jj in 0:11){
    mydates[(jj+1)+12*ii,1]<-as.Date(paste(as.character(the_year),month_formating[(jj+curr_month-1)%%12+1],"-01",sep=""))-time_zero_date
    mydates[(jj+1)+12*ii,2]<-(jj+curr_month-1)%%12+1
    if(mydates[(jj+1)+12*ii,2]==12){
      the_year<-the_year+1
    }
  }
}

#this returns the relevant row from the matrix of dates (relating to month changes) given a time (in days)
current_daymonth<-function(time_from_current_date){
  past_dates<-which(mydates$days_until_rate_change<=time_from_current_date)
  if(length(past_dates)==0){
    current_row<-length(mydates[,1])
  }else{
    current_row<-past_dates[length(past_dates)]
  }
  return(current_row)
}

#this generates the next time that a mosquito is generated by an individual (inhomogeneous poisson process for seasonal model)
mozzy_generation_times<-function(t,new_mozzys,tR){
  
  the_season_row<-current_daymonth(t)
  the_season<-mydates$month[the_season_row]
  the1st<-mydates$days_until_rate_change[the_season_row]
  t_delta<-rexp(1,rate=new_mozzys[the_season])
  newt_season_row<-current_daymonth(t2+t_delta)  #check!!! (t)
  newt_1st<-mydates$days_until_rate_change[newt_season_row]
  
  while(newt_1st!=the1st & (the1st)<min(tR,max_t)){
    the_season_row<-the_season_row+1
    the_season<-mydates$month[the_season_row]
    the1st<-mydates$days_until_rate_change[the_season_row]
    t_delta<-the1st-t+rexp(1,rate=new_mozzys[the_season])
    newt_season_row<-current_daymonth(t2+t_delta)
    newt_1st<-mydates$days_until_rate_change[newt_season_row]
  }
  
  return(t_delta)
}


#need an adjacency matrix of distances.
Distances<-matrix(NA,nrow=length(hh_labels),ncol=length(hh_labels))
for(ii in 1:length(hh_labels)){
  Distances[,ii]<-((people_locations[ii,1]-people_locations[,1])^2+(people_locations[ii,2]-people_locations[,2])^2)^(1/2)
  Distances[ii,ii]<-0
}
max_stack_h<-10000
max_stack_m<-300000
#Human data frame (saves times of exposure infectiousness and recovery)
human_stack<-data.frame(matrix(NA,nrow=max_stack_h,ncol=5))
names(human_stack)<-c("hh_id","ind_id","t","state","df_index")

#mosquito stack saves newly infected mosquitos and the transitions through their life (from the time of infection)
mosquito_stack<-data.frame(matrix(NA,nrow=max_stack_m,ncol=5))
names(mosquito_stack)<-c("mosquito_id","t","event","infectious_status","hh_id")

#infectiousness times
tI=matrix(NA,nrow=max_stack_h,ncol=1) 

#recovery times
tR=matrix(NA,nrow=max_stack_h,ncol=1)

#the possible infection stack is all that is needed to generate realisations of the infection process (without saving all of the mosqito level events)
#events in the stack will cause an infection in humans in the relevant household with probability S/N
possible_infection_stack<-data.frame(matrix(NA,nrow=max_stack_h,ncol=4))
names(possible_infection_stack)<-c("hh_id","ind_id","t")
exposure_time<-matrix(NA,nrow=max_stack_h,ncol=1)
temp_death_time<-matrix(NA,nrow=max_stack_h,ncol=1)
stack_size<-0
inf_stack_size<-0

#mosquito count
m_count<-0

#time/counter
t<-0


#the sick people (with plasmodium falciparum) (change to "3" for Pv)
sick_people<-which(ind_level_data$malaria==1)

#the number of events on the stack for humans (just to keep track of all of the events)
h_stack_count<-0;


human_state<-matrix(0,nrow=length(ind_level_data$hh_id),ncol=1)
human_state[sick_people]<-1
initial_I<-length(sick_people)
#initial recovery times
#of humans
for( jj in 1:length(sick_people)){
  h_stack_count<-h_stack_count+1
  human_stack$hh_id[h_stack_count]<-ind_level_data$hh_id[sick_people[jj]]
  human_stack$ind_id[h_stack_count]<-ind_level_data$ind_id[sick_people[jj]]
  human_stack$df_index[h_stack_count]<-sick_people[jj]
  
  tI[h_stack_count]<-0
  
  human_stack$t[h_stack_count]<-tI[h_stack_count]+rexp(1,rate=gammaH)
  
  tR[h_stack_count]<-human_stack$t[h_stack_count]
  
  #let 1 be exposure, 2 infectiousness and 3 recovery
  human_stack$state[h_stack_count]<-3
  
  #new_mozzys<-ind_level_data$m_mosquito_rate[sick_people[jj]]
  new_mozzys<-seasonal_creation[sick_people[jj],]
  #cum_new_mozzys<-cumsum(new_mozzys)
  
  #generate all mosquitos from the existing sick people
  t2<-tI[jj]
  
  t_delta<-mozzy_generation_times(t2,new_mozzys,tR[jj])
  
  while((t2+t_delta)<min(tR[jj],max_t)){
    #generate/record time of event
    t2<-t2+t_delta
    #generate a mosquito into the relevant household
    ind_moz_index<-sick_people[jj]
    m_count<-m_count+1
    
    #currently let all mosquitoes be introduced as full 
    # 1: hungry, 2: full, 3: dead, hh_id: travelling to hh_id
    
    # now to add the mosquitoes movements to the stack
    # THESE CAN BE CHANGED TO NOT BE EXPONENTIAL
    temp_infectious_time<-t2+rexp(1,rate=sigmaM)
    exposure_time[m_count]<-temp_infectious_time
    temp_death_time[m_count]<-t2+rexp(1,rate=gammaM)
    
    mozzy_id<-m_count
    temp_hh<-ind_level_data$hh_id[ind_moz_index]
    temp_mozzy_hh_index<-which(hh_labels==temp_hh)
    temp_t<-t2
    temp_state<-2 
    temp_infectious_state<-0
    
    stack_size<-stack_size+1
    mosquito_stack$mosquito_id[stack_size]<-mozzy_id
    mosquito_stack$hh_id[stack_size]<-temp_hh
    mosquito_stack$t[stack_size]<-temp_t
    mosquito_stack$event[stack_size]<-temp_state
    mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
    
    while(temp_t<temp_death_time[m_count] & temp_state!=3 & temp_t<max_t){
      
      #If the mosquito is hungry it bites
      if(temp_state==1){
        # if hungry bite and stay hungry, bite and get full or bite+die
        temp_t<-temp_t+rexp(1,rate=bite_rate)
        rand_event=runif(1)
        if(rand_event<multiple_meal){
          #bite and not full
          temp_state<-1
        }else if(rand_event<(multiple_meal+(1-multiple_meal)*(1-hh_deathonbite[temp_mozzy_hh_index]))){
          #full after bite
          temp_state<-2
        }else{
          #dead on bite
          temp_state<-3
        }
        
        #generates effective contact between an infectious mosquito and a human
        if(temp_t>temp_infectious_time & temp_t<temp_death_time[m_count] & temp_t<max_t){
          rand_inf=runif(1)
          if(rand_inf<transMH_per_bite){
            inf_stack_size<-inf_stack_size+1
            possible_infection_stack$hh_id[inf_stack_size]<-temp_hh
            possible_infection_stack$t[inf_stack_size]<-temp_t
            possible_infection_stack$ind_id[inf_stack_size]<-ceiling(runif(1)*N[temp_mozzy_hh_index])
          }
        }
        
        #If the mosquito is full it moves after a holding time
      }else if(temp_state==2){
        
        #generate time that the mosquito will be ready to travel
        temp_t<-temp_t+rexp(1,rate=eta)
        
        the_season<-mydates$month[current_daymonth(temp_t)]
        
        #the mosquitos choice of new hh
        hhprobs<-(scaled_seasonal_MAP[,the_season]*hh_bite_prop)*(pnorm(Distances[,temp_mozzy_hh_index],0,10/3)/pnorm(0,0,10/3))
        
        #some data issue where non-unique household locations exits (check this)
        hhprobs[which(Distances[,temp_mozzy_hh_index]==0)]<-0
        
        #generate the next location
        cum_new_hh<-cumsum(hhprobs)
        temp_state<-hh_labels[which((runif(1)*cum_new_hh[length(cum_new_hh)])<cum_new_hh)[1]]
        
        #If the mosquito is no longer full it travels
      }else{
        temp_hh<-temp_state
        next_hh_index<-which(hh_labels==temp_state)
        temp_t<-temp_t+rexp(1,rate=flight_rate/(Distances[temp_mozzy_hh_index,next_hh_index]))
        temp_mozzy_hh_index<-next_hh_index
        temp_state<-1
        
      }
      
      #changes the mosquito to the infectious class (for purposes of assessing effective contact)
      if(temp_t>temp_infectious_time){
        temp_infectious_state<-1
      }
      
      if(temp_t<temp_death_time[m_count] & temp_t<max_t){
        stack_size<-stack_size+1
        mosquito_stack$mosquito_id[stack_size]<-mozzy_id
        mosquito_stack$hh_id[stack_size]<-temp_hh
        mosquito_stack$t[stack_size]<-temp_t
        mosquito_stack$event[stack_size]<-temp_state
        mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
      }
    }
    
    #if the mozzy didn't die from a natural bite and the next event would have occured before the end of the simulation period
    if(mosquito_stack$event[stack_size]!=3){ #& temp_death_time[m_count]<max_t){
      stack_size<-stack_size+1
      mosquito_stack$mosquito_id[stack_size]<-mozzy_id
      mosquito_stack$hh_id[stack_size]<-temp_hh
      mosquito_stack$t[stack_size]<-min(temp_death_time[m_count],max_t)
      mosquito_stack$event[stack_size]<-3
      mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
    }
    #propose new mosquito introduction from sick person zz
    t_delta<-mozzy_generation_times(t2,new_mozzys,tR[jj])
  }
}


#possible_infection_stack<-possible_infection_stack[order(possible_infection_stack$t),]
if(sum(1*(!is.na(possible_infection_stack$t)))!=0){
  poss_inf_index<-which.min(possible_infection_stack$t)
  t<-possible_infection_stack$t[poss_inf_index]
}else{
  t<-max_t+1
}

while(sum(1*(!is.na(possible_infection_stack$t)))!=0 & t<max_t){
  
  #finds the index of the next possible infection event
  poss_inf_index<-which.min(possible_infection_stack$t)
  
  #find the relevant row in the data frame for the individual
  inf_row_num<-which(ind_level_data$hh_id==possible_infection_stack$hh_id[poss_inf_index] & ind_level_data$ind_id==possible_infection_stack$ind_id[poss_inf_index])
  
  #check events of the person on the stack (prior to the possible transmission event)
  person_events<-which(human_stack$df_index==inf_row_num & human_stack$t<possible_infection_stack$t[poss_inf_index])
  
  #if the person isn't on the stack they are susceptible
  if(length(person_events)==0){
    #add this infection to the stack
    add_to_stack<-TRUE
    t<-possible_infection_stack$t[poss_inf_index]
    #if the person is on the stack, but their last event was a recovery then they are susceptible at the time of the bite
  }else if(human_stack$state[which.max(human_stack$t[person_events])]==3){
    add_to_stack<-TRUE
    t<-possible_infection_stack$t[poss_inf_index]
  }else{
    add_to_stack<-FALSE
  }
  
  possible_infection_stack$t[poss_inf_index]<-NA
  possible_infection_stack$hh_id[poss_inf_index]<-NA
  possible_infection_stack$ind_id[poss_inf_index]<-NA
  
  if(add_to_stack){
    
    #exposure event on stack (just for plots)
    h_stack_count<-h_stack_count+1
    human_stack$hh_id[h_stack_count]<-ind_level_data$hh_id[inf_row_num]
    human_stack$ind_id[h_stack_count]<-ind_level_data$ind_id[inf_row_num]
    human_stack$df_index[h_stack_count]<-inf_row_num
    human_stack$t[h_stack_count]<-t
    human_stack$state[h_stack_count]<-1
    
    #infectious event on stack
    h_stack_count<-h_stack_count+1
    human_stack$hh_id[h_stack_count]<-ind_level_data$hh_id[inf_row_num]
    human_stack$ind_id[h_stack_count]<-ind_level_data$ind_id[inf_row_num]
    human_stack$df_index[h_stack_count]<-inf_row_num
    human_stack$t[h_stack_count]<-t+rexp(1,rate=sigmaH)
    tI[h_stack_count]<-human_stack$t[h_stack_count]
    human_stack$state[h_stack_count]<-2
    
    #recovery event on stack
    h_stack_count<-h_stack_count+1
    human_stack$hh_id[h_stack_count]<-ind_level_data$hh_id[inf_row_num]
    human_stack$ind_id[h_stack_count]<-ind_level_data$ind_id[inf_row_num]
    human_stack$df_index[h_stack_count]<-inf_row_num
    human_stack$t[h_stack_count]<-tI[h_stack_count-1]+rexp(1,rate=gammaH)
    tR[h_stack_count]<-human_stack$t[h_stack_count]
    human_stack$state[h_stack_count]<-3
    
    #new_mozzys<-ind_level_data$m_mosquito_rate[inf_row_num]
    new_mozzys<-seasonal_creation[inf_row_num,]
    
    #generate all mosquitos from the existing sick people
    t2<-tI[h_stack_count-1]
    t_delta<-mozzy_generation_times(t2,new_mozzys,tR[jj])
    while((t2+t_delta)<min(tR[h_stack_count],max_t)){
      #generate/record time of event
      t2<-t2+t_delta
      #generate a mosquito into the relevant household
      ind_moz_index<-inf_row_num
      
      #what do I need to do for the mosquito?
      # Malaria mosquito activity is independent of the state of the system, assuming a fixed treatment of households over their
      # lifetime (the impact on infection is state dependent though)
      m_count<-m_count+1
      
      #currently let all mosquitoes be introduced as full (maybe change this later). 
      # 1: hungry, 2: full, 3: dead, hh_id: travelling to hh_id
      
      # now to add the mosquitoes movements to the stack
      # THESE CAN BE CHANGED TO NOT BE EXPONENTIAL
      temp_infectious_time<-t2+rexp(1,rate=sigmaM)
      exposure_time[m_count]<-temp_infectious_time
      temp_death_time[m_count]<-t2+rexp(1,rate=gammaM)
      
      
      mozzy_id<-m_count
      temp_hh<-ind_level_data$hh_id[ind_moz_index]
      temp_mozzy_hh_index<-which(hh_labels==temp_hh)
      temp_t<-t2
      temp_state<-2 
      temp_infectious_state<-0
      
      stack_size<-stack_size+1
      mosquito_stack$mosquito_id[stack_size]<-mozzy_id
      mosquito_stack$hh_id[stack_size]<-temp_hh
      mosquito_stack$t[stack_size]<-temp_t
      mosquito_stack$event[stack_size]<-temp_state
      mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
      
      while(temp_t<temp_death_time[m_count] & temp_state!=3 & temp_t<max_t){
        
        #If the mosquito is hungry it bites
        if(temp_state==1){
          # if hungry bite and stay hungry, bite and get full or bite+die
          temp_t<-temp_t+rexp(1,rate=bite_rate)
          rand_event=runif(1)
          if(rand_event<multiple_meal){
            #bite and not full
            temp_state<-1
          }else if(rand_event<(multiple_meal+(1-multiple_meal)*(1-hh_deathonbite[temp_mozzy_hh_index]))){
            #full
            temp_state<-2
          }else{
            #dead on bite
            temp_state<-3
          }
          
          #generates effective contact between an infectious mosquito and a human
          if(temp_t>temp_infectious_time & temp_t<temp_death_time[m_count] & temp_t<max_t){
            rand_inf=runif(1)
            if(rand_inf<transMH_per_bite){
              inf_stack_size<-inf_stack_size+1
              possible_infection_stack$hh_id[inf_stack_size]<-temp_hh
              possible_infection_stack$t[inf_stack_size]<-temp_t
              possible_infection_stack$ind_id[inf_stack_size]<-ceiling(runif(1)*N[temp_mozzy_hh_index])
            }
          }
          
          #If the mosquito is full it moves after a holding time
        }else if(temp_state==2){
          
          #generate time that the mosquito will be ready to travel
          temp_t<-temp_t+rexp(1,rate=eta)
          
          #the mosquitos choice of new hh
          the_season<-mydates$month[ current_daymonth(temp_t)]
          
          hhprobs<-(scaled_seasonal_MAP[,the_season]*hh_bite_prop)*(pnorm(Distances[,temp_mozzy_hh_index],0,10/3)/pnorm(0,0,10/3))
          
          #some data issue where non-unique household locations exits (check this)
          hhprobs[which(Distances[,temp_mozzy_hh_index]==0)]<-0
          
          #generate the next location
          cum_new_hh<-cumsum(hhprobs)
          temp_state<-hh_labels[which((runif(1)*cum_new_hh[length(cum_new_hh)])<cum_new_hh)[1]]
          
          #If the mosquito is no longer full it travels
        }else{
          temp_hh<-temp_state
          next_hh_index<-which(hh_labels==temp_state)
          temp_t<-temp_t+rexp(1,rate=flight_rate/(Distances[temp_mozzy_hh_index,next_hh_index]))
          temp_mozzy_hh_index<-next_hh_index
          temp_state<-1
          
        }
        
        #changes the mosquito to the infectious class (for purposes of assessing effective contact)
        if(temp_t>temp_infectious_time){
          temp_infectious_state<-1
        }
        
        if(temp_t<temp_death_time[m_count] & temp_t<max_t){
          stack_size<-stack_size+1
          mosquito_stack$mosquito_id[stack_size]<-mozzy_id
          mosquito_stack$hh_id[stack_size]<-temp_hh
          mosquito_stack$t[stack_size]<-temp_t
          mosquito_stack$event[stack_size]<-temp_state
          mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
        }
      }
      
      #if the mozzy didn't die from a natural bite and the next event would have occured before the end of the simulation period
      if(mosquito_stack$event[stack_size]!=3){# & temp_death_time<max_t){
        stack_size<-stack_size+1
        mosquito_stack$mosquito_id[stack_size]<-mozzy_id
        mosquito_stack$hh_id[stack_size]<-temp_hh
        mosquito_stack$t[stack_size]<-min(temp_death_time[m_count],max_t)
        mosquito_stack$event[stack_size]<-3
        mosquito_stack$infectious_status[stack_size]<-temp_infectious_state
      }
      #propose new mosquito introduction from sick person zz
      t_delta<-mozzy_generation_times(t2,new_mozzys,tR[jj])
    }

  }  
}


ordered_human_stack<-human_stack[order(human_stack$t),]
Eh<-cumsum(1*(ordered_human_stack$state==1)-1*(ordered_human_stack$state==2))
Ih<-initial_I+cumsum(1*(ordered_human_stack$state==2)-1*(ordered_human_stack$state==3))
human_I<-data.frame(cbind(ordered_human_stack$t[1:h_stack_count],Eh[1:h_stack_count],Ih[1:h_stack_count]))
names(human_I)<-c("t","E","I")
human_I<-human_I[which(human_I$t<max_t),]

ordered_m_stack<-mosquito_stack[order(mosquito_stack$t),]
ordered_m_stack<-ordered_m_stack[1:stack_size,]
state_vec<-data.frame(matrix(NA,ncol=5,nrow=3*m_count))
names(state_vec)<-c('tm','event','Em','Im','Rm')
row_state<-0;
for(ii in 1:m_count){
  #data relating to each mosquito
  mozzy_ii<-which(ordered_m_stack$mosquito_id==ii)
  
  #recording the exposure
  state_vec[row_state+1,1]<-ordered_m_stack$t[mozzy_ii[1]]
  state_vec[row_state+1,2]<-1
  
  #recording the removal
  tR_index<-which(ordered_m_stack$event[mozzy_ii]==3)
  if(length(tR_index)==0){
    # print(ii)
    state_vec[row_state+3,1]<-max_t
  }else{
    state_vec[row_state+3,1]<-ordered_m_stack$t[mozzy_ii[tR_index]]
  }
  state_vec[row_state+3,2]<-3
  
  #recording infectiousness
  state_vec[row_state+2,1]<-min(state_vec[row_state+3,1],exposure_time[ii])
  #note the infectiousness time effectively happens at the same time as the recovery time if removal occures prior to infectiousness
  state_vec[row_state+2,2]<-2
  
  row_state<-row_state+3
}
state_vec<-state_vec[order(state_vec[,1]),]
state_vec$Em<-cumsum(1*(state_vec$event==1)-1*(state_vec$event==2))
state_vec$Im<-cumsum(1*(state_vec$event==2)-1*(state_vec$event==3))
#R is irrelevant in infinite population of mosquitos
state_vec$Rm<-cumsum(1*(state_vec$event==3))

state_vec<-state_vec[which(state_vec$tm<=max_t),]


stuff<-data.frame(matrix(NA,ncol=length(human_I[1,]),nrow=(length(state_vec[,1])-length(human_I[,1]))))
names(stuff)<-names(human_I)
big_df<-cbind(state_vec,rbind(human_I,stuff))



#set directories for saved figures
setwd("~/ABM")

#####Figure 
#Eample trajectory

### xtick labels in year
day=seq(from = 0, to = 3*max_t, by = 365)
year= ceiling(day/365)- ceiling(day[1]/365)
year0= year-2
yr=as.character(year) ## number to string
yr0=as.character(year0) ## number to string

big_df<-subset(big_df,tm<max_t)
########Human_mosq_subplot
hum_EI<-ggplot()+ 
  geom_line(data=big_df, aes(x=t, y=E,color="Exposed"), linetype="solid")+
  geom_line(data=big_df, aes(x=t, y=I,color="Infected"), linetype="solid")+
  labs(y= "Number of humans", x = "Time (years)")+
  scale_x_continuous(breaks=day,labels=yr)+ #show chosen xtick and convert them to year
  scale_color_manual(values = c("Exposed"="#fdb462","Infected"="#fb8072"))+
  theme(axis.text=element_text(size=12),legend.key.width = unit(1, "cm"),
        axis.title=element_text(size=12),legend.text=element_text(size=12),legend.title=element_text(size=12))+
  theme(legend.position="bottom",legend.box="vertical", legend.margin=margin(),legend.text=element_text(size=12))+
  labs(color = "Colour", position='bottom')

mos_EI<-ggplot()+ 
  geom_line(data=big_df, aes(x=tm, y=Em,color="Exposed"), linetype="solid")+
  geom_line(data=big_df, aes(x=tm, y=Im,color="Infected"), linetype="solid")+
  labs(y= "Number of mosquitoes", x = "Time (years)")+
  scale_x_continuous(breaks=day,labels=yr)+ #show chosen xtick and convert them to year
  scale_color_manual(values = c("Exposed"="#fdb462","Infected"="#fb8072"))+
  theme(axis.text=element_text(size=12),legend.key.width = unit(1, "cm"),
        axis.title=element_text(size=12),legend.text=element_text(size=12),legend.title=element_text(size=12))+
  theme(legend.position="bottom",legend.box="vertical", legend.margin=margin(),legend.text=element_text(size=12))+
  labs(color = "Colour", position='bottom')


hum_mosq<-ggarrange(hum_EI,mos_EI, 
                    labels = "AUTO",
                    common.legend = TRUE, legend = "bottom",
                    ncol = 2, nrow = 1
)
ggsave(plot = hum_mosq, width = 10, height =4, dpi = 500, filename = "Human_mosq_EI_base.png") 
